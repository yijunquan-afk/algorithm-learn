# 荷兰国旗问题

## 问题

给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地 对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

必须在不使用库内置的 sort 函数的情况下解决这个问题。

### 解法思路

这个问题是经典的 **荷兰国旗问题**（Dutch National Flag Problem），要求通过一次遍历将数组中的0、1、2原地排序。核心思想是通过三个指针划分三个区域：

- **左指针 `left`**：标记0的右边界（所有左边的元素都是0）。
- **右指针 `right`**：标记2的左边界（所有右边的元素都是2）。
- **当前指针 `current`**：遍历数组，根据当前元素的值决定如何交换。

#### 操作步骤：

1. **初始化指针**：`left = 0`，`right = len(nums)-1`，`current = 0`。

2. **遍历条件**：`current <= right`（确保所有元素被处理）。

3. 分情况处理

   ：

   - **当前元素为0**：与左指针交换，`left`和`current`均右移。
   - **当前元素为2**：与右指针交换，`right`左移（注意此时`current`不移动，因为交换后的元素可能是0或2）。
   - **当前元素为1**：直接右移`current`。

### 代码实现

```
def sortColors(nums):
    left = 0 
    right = len(nums) - 1 
    current = 0 
    
    while current <= right:
        if nums[current] == 0:
            nums[left], nums[current] = nums[current], nums[left]
            left += 1 
            current += 1 
        elif nums[current] == 2:
            nums[right], nums[current] = nums[current], nums[right]
            right -= 1 
        else:
            current += 1 
```

### 复杂度分析

- **时间复杂度**：O(n)，仅需一次遍历。
- **空间复杂度**：O(1)，原地操作，仅用常数空间。

### 关键点解释

1. 交换0的逻辑：
   - 将0移动到左指针的位置，此时左边界右移（`left += 1`）。
   - 当前指针右移（`current += 1`），因为交换后的元素不可能是2（左指针左侧只有0或1）。
2. 交换2的逻辑：
   - 将2移动到右指针的位置，此时右边界左移（`right -= 1`）。
   - 当前指针不移动，因为交换后的元素可能是0或2，需要再次处理。
3. 跳过1的逻辑：
   - 遇到1时直接移动当前指针，保证中间区域自然形成。

### 示例验证

以输入 `nums = [2, 0, 2, 1, 1, 0]` 为例：

1. 初始状态：`[2,0,2,1,1,0]`，`left=0`，`right=5`，`current=0`。
2. `nums[0]=2`：与右指针交换 → `[0,0,2,1,1,2]`，`right=4`，`current`仍为0。
3. `nums[0]=0`：与左指针交换（原地），`left=1`，`current=1`。
4. `nums[1]=0`：继续交换，`left=2`，`current=2`。
5. `nums[2]=2`：与右指针交换 → `[0,0,1,1,2,2]`，`right=3`，`current=2`。
6. `nums[2]=1`：跳过，`current=3`。
7. 循环结束，最终数组有序。